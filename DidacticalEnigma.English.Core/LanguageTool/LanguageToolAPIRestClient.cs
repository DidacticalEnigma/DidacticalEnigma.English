// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;
using DidacticalEnigma.English.LanguageTool.Models;

namespace DidacticalEnigma.English.LanguageTool
{
    internal partial class LanguageToolAPIRestClient
    {
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> Initializes a new instance of LanguageToolAPIRestClient. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="endpoint"> server parameter. </param>
        public LanguageToolAPIRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Uri endpoint = null)
        {
            _endpoint = endpoint ?? new Uri("https://api.languagetoolplus.com/v2");
            ClientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
        }

        internal HttpMessage CreateCheckRequest(string language, string text, string data, string username, string apiKey, string dicts, string motherTongue, string preferredVariants, string enabledRules, string disabledRules, string enabledCategories, string disabledCategories, bool? enabledOnly, PostContentSchemaLevel? level)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/check", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/x-www-form-urlencoded");
            var content = new FormUrlEncodedContent();
            if (text != null)
            {
                content.Add("text", text);
            }
            if (data != null)
            {
                content.Add("data", data);
            }
            content.Add("language", language);
            if (username != null)
            {
                content.Add("username", username);
            }
            if (apiKey != null)
            {
                content.Add("apiKey", apiKey);
            }
            if (dicts != null)
            {
                content.Add("dicts", dicts);
            }
            if (motherTongue != null)
            {
                content.Add("motherTongue", motherTongue);
            }
            if (preferredVariants != null)
            {
                content.Add("preferredVariants", preferredVariants);
            }
            if (enabledRules != null)
            {
                content.Add("enabledRules", enabledRules);
            }
            if (disabledRules != null)
            {
                content.Add("disabledRules", disabledRules);
            }
            if (enabledCategories != null)
            {
                content.Add("enabledCategories", enabledCategories);
            }
            if (disabledCategories != null)
            {
                content.Add("disabledCategories", disabledCategories);
            }
            if (enabledOnly != null)
            {
                content.Add("enabledOnly", enabledOnly.Value.ToString());
            }
            if (level != null)
            {
                content.Add("level", level.Value.ToString());
            }
            request.Content = content;
            return message;
        }

        /// <summary> The main feature - check a text with LanguageTool for possible style and grammar issues. </summary>
        /// <param name="language"> A language code like `en-US`, `de-DE`, `fr`, or `auto` to guess the language automatically (see `preferredVariants` below). For languages with variants (English, German, Portuguese) spell checking will only be activated when you specify the variant, e.g. `en-GB` instead of just `en`. </param>
        /// <param name="text"> The text to be checked. This or &apos;data&apos; is required. </param>
        /// <param name="data">
        /// The text to be checked, given as a JSON document that specifies what&apos;s text and what&apos;s markup. This or &apos;text&apos; is required. Markup will be ignored when looking for errors. Example text: &lt;pre&gt;A &amp;lt;b&gt;test&amp;lt;/b&gt;&lt;/pre&gt;JSON for the example text: &lt;pre&gt;{&quot;annotation&quot;:[
        ///  {&quot;text&quot;: &quot;A &quot;},
        ///  {&quot;markup&quot;: &quot;&amp;lt;b&gt;&quot;},
        ///  {&quot;text&quot;: &quot;test&quot;},
        ///  {&quot;markup&quot;: &quot;&amp;lt;/b&gt;&quot;}
        /// ]}&lt;/pre&gt; &lt;p&gt;If you have markup that should be interpreted as whitespace, like &lt;tt&gt;&amp;lt;p&amp;gt;&lt;/tt&gt; in HTML, you can have it interpreted like this: &lt;pre&gt;{&quot;markup&quot;: &quot;&amp;lt;p&amp;gt;&quot;, &quot;interpretAs&quot;: &quot;\n\n&quot;}&lt;/pre&gt;&lt;p&gt;The &apos;data&apos; feature is not limited to HTML or XML, it can be used for any kind of markup. Entities will need to be expanded in this input.
        /// </param>
        /// <param name="username"> Set to get Premium API access: Your username/email as used to log in at languagetool.org. </param>
        /// <param name="apiKey"> Set to get Premium API access: &lt;a target=&apos;_blank&apos; href=&apos;https://languagetool.org/editor/settings/api&apos;&gt;your API key&lt;/a&gt;. </param>
        /// <param name="dicts"> Comma-separated list of dictionaries to include words from; uses special default dictionary if this is unset. </param>
        /// <param name="motherTongue"> A language code of the user&apos;s native language, enabling false friends checks for some language pairs. </param>
        /// <param name="preferredVariants"> Comma-separated list of preferred language variants. The language detector used with `language=auto` can detect e.g. English, but it cannot decide whether British English or American English is used. Thus this parameter can be used to specify the preferred variants like `en-GB` and `de-AT`. Only available with `language=auto`. You should set variants for at least German and English, as otherwise the spell checking will not work for those, as no spelling dictionary can be selected for just `en` or `de`. </param>
        /// <param name="enabledRules"> IDs of rules to be enabled, comma-separated. </param>
        /// <param name="disabledRules"> IDs of rules to be disabled, comma-separated. </param>
        /// <param name="enabledCategories"> IDs of categories to be enabled, comma-separated. </param>
        /// <param name="disabledCategories"> IDs of categories to be disabled, comma-separated. </param>
        /// <param name="enabledOnly"> If true, only the rules and categories whose IDs are specified with `enabledRules` or `enabledCategories` are enabled. </param>
        /// <param name="level"> If set to `picky`, additional rules will be activated, i.e. rules that you might only find useful when checking formal text. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="language"/> is null. </exception>
        public async Task<Response<PathsWm9F5YCheckPostResponses200ContentApplicationJsonSchema>> CheckAsync(string language, string text = null, string data = null, string username = null, string apiKey = null, string dicts = null, string motherTongue = null, string preferredVariants = null, string enabledRules = null, string disabledRules = null, string enabledCategories = null, string disabledCategories = null, bool? enabledOnly = null, PostContentSchemaLevel? level = null, CancellationToken cancellationToken = default)
        {
            if (language == null)
            {
                throw new ArgumentNullException(nameof(language));
            }

            using var message = CreateCheckRequest(language, text, data, username, apiKey, dicts, motherTongue, preferredVariants, enabledRules, disabledRules, enabledCategories, disabledCategories, enabledOnly, level);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        PathsWm9F5YCheckPostResponses200ContentApplicationJsonSchema value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = PathsWm9F5YCheckPostResponses200ContentApplicationJsonSchema.DeserializePathsWm9F5YCheckPostResponses200ContentApplicationJsonSchema(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> The main feature - check a text with LanguageTool for possible style and grammar issues. </summary>
        /// <param name="language"> A language code like `en-US`, `de-DE`, `fr`, or `auto` to guess the language automatically (see `preferredVariants` below). For languages with variants (English, German, Portuguese) spell checking will only be activated when you specify the variant, e.g. `en-GB` instead of just `en`. </param>
        /// <param name="text"> The text to be checked. This or &apos;data&apos; is required. </param>
        /// <param name="data">
        /// The text to be checked, given as a JSON document that specifies what&apos;s text and what&apos;s markup. This or &apos;text&apos; is required. Markup will be ignored when looking for errors. Example text: &lt;pre&gt;A &amp;lt;b&gt;test&amp;lt;/b&gt;&lt;/pre&gt;JSON for the example text: &lt;pre&gt;{&quot;annotation&quot;:[
        ///  {&quot;text&quot;: &quot;A &quot;},
        ///  {&quot;markup&quot;: &quot;&amp;lt;b&gt;&quot;},
        ///  {&quot;text&quot;: &quot;test&quot;},
        ///  {&quot;markup&quot;: &quot;&amp;lt;/b&gt;&quot;}
        /// ]}&lt;/pre&gt; &lt;p&gt;If you have markup that should be interpreted as whitespace, like &lt;tt&gt;&amp;lt;p&amp;gt;&lt;/tt&gt; in HTML, you can have it interpreted like this: &lt;pre&gt;{&quot;markup&quot;: &quot;&amp;lt;p&amp;gt;&quot;, &quot;interpretAs&quot;: &quot;\n\n&quot;}&lt;/pre&gt;&lt;p&gt;The &apos;data&apos; feature is not limited to HTML or XML, it can be used for any kind of markup. Entities will need to be expanded in this input.
        /// </param>
        /// <param name="username"> Set to get Premium API access: Your username/email as used to log in at languagetool.org. </param>
        /// <param name="apiKey"> Set to get Premium API access: &lt;a target=&apos;_blank&apos; href=&apos;https://languagetool.org/editor/settings/api&apos;&gt;your API key&lt;/a&gt;. </param>
        /// <param name="dicts"> Comma-separated list of dictionaries to include words from; uses special default dictionary if this is unset. </param>
        /// <param name="motherTongue"> A language code of the user&apos;s native language, enabling false friends checks for some language pairs. </param>
        /// <param name="preferredVariants"> Comma-separated list of preferred language variants. The language detector used with `language=auto` can detect e.g. English, but it cannot decide whether British English or American English is used. Thus this parameter can be used to specify the preferred variants like `en-GB` and `de-AT`. Only available with `language=auto`. You should set variants for at least German and English, as otherwise the spell checking will not work for those, as no spelling dictionary can be selected for just `en` or `de`. </param>
        /// <param name="enabledRules"> IDs of rules to be enabled, comma-separated. </param>
        /// <param name="disabledRules"> IDs of rules to be disabled, comma-separated. </param>
        /// <param name="enabledCategories"> IDs of categories to be enabled, comma-separated. </param>
        /// <param name="disabledCategories"> IDs of categories to be disabled, comma-separated. </param>
        /// <param name="enabledOnly"> If true, only the rules and categories whose IDs are specified with `enabledRules` or `enabledCategories` are enabled. </param>
        /// <param name="level"> If set to `picky`, additional rules will be activated, i.e. rules that you might only find useful when checking formal text. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="language"/> is null. </exception>
        public Response<PathsWm9F5YCheckPostResponses200ContentApplicationJsonSchema> Check(string language, string text = null, string data = null, string username = null, string apiKey = null, string dicts = null, string motherTongue = null, string preferredVariants = null, string enabledRules = null, string disabledRules = null, string enabledCategories = null, string disabledCategories = null, bool? enabledOnly = null, PostContentSchemaLevel? level = null, CancellationToken cancellationToken = default)
        {
            if (language == null)
            {
                throw new ArgumentNullException(nameof(language));
            }

            using var message = CreateCheckRequest(language, text, data, username, apiKey, dicts, motherTongue, preferredVariants, enabledRules, disabledRules, enabledCategories, disabledCategories, enabledOnly, level);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        PathsWm9F5YCheckPostResponses200ContentApplicationJsonSchema value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = PathsWm9F5YCheckPostResponses200ContentApplicationJsonSchema.DeserializePathsWm9F5YCheckPostResponses200ContentApplicationJsonSchema(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetLanguagesRequest()
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/languages", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Get a list of supported languages. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<Response<IReadOnlyList<Get200ApplicationJsonItemsItem>>> GetLanguagesAsync(CancellationToken cancellationToken = default)
        {
            using var message = CreateGetLanguagesRequest();
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        IReadOnlyList<Get200ApplicationJsonItemsItem> value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        List<Get200ApplicationJsonItemsItem> array = new List<Get200ApplicationJsonItemsItem>();
                        foreach (var item in document.RootElement.EnumerateArray())
                        {
                            array.Add(Get200ApplicationJsonItemsItem.DeserializeGet200ApplicationJsonItemsItem(item));
                        }
                        value = array;
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Get a list of supported languages. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public Response<IReadOnlyList<Get200ApplicationJsonItemsItem>> GetLanguages(CancellationToken cancellationToken = default)
        {
            using var message = CreateGetLanguagesRequest();
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        IReadOnlyList<Get200ApplicationJsonItemsItem> value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        List<Get200ApplicationJsonItemsItem> array = new List<Get200ApplicationJsonItemsItem>();
                        foreach (var item in document.RootElement.EnumerateArray())
                        {
                            array.Add(Get200ApplicationJsonItemsItem.DeserializeGet200ApplicationJsonItemsItem(item));
                        }
                        value = array;
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetUserDictionaryWordsRequest(string username, string apiKey, int? offset, int? limit, string dicts)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/words", false);
            if (offset != null)
            {
                uri.AppendQuery("offset", offset.Value, true);
            }
            if (limit != null)
            {
                uri.AppendQuery("limit", limit.Value, true);
            }
            uri.AppendQuery("username", username, true);
            uri.AppendQuery("apiKey", apiKey, true);
            if (dicts != null)
            {
                uri.AppendQuery("dicts", dicts, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> List words in the user&apos;s personal dictionaries. </summary>
        /// <param name="username"> Your username as used to log in at languagetool.org. </param>
        /// <param name="apiKey"> &lt;a target=&apos;_blank&apos; href=&apos;https://languagetool.org/editor/settings/api&apos;&gt;Your API key&lt;/a&gt;. </param>
        /// <param name="offset"> Offset of where to start in the list of words. Defaults to 0. </param>
        /// <param name="limit"> Maximum number of words to return. Defaults to 10. </param>
        /// <param name="dicts"> Comma-separated list of dictionaries to include words from; uses special default dictionary if this is unset. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="username"/> or <paramref name="apiKey"/> is null. </exception>
        public async Task<Response<Paths19M51AqWordsGetResponses200ContentApplicationJsonSchema>> GetUserDictionaryWordsAsync(string username, string apiKey, int? offset = null, int? limit = null, string dicts = null, CancellationToken cancellationToken = default)
        {
            if (username == null)
            {
                throw new ArgumentNullException(nameof(username));
            }
            if (apiKey == null)
            {
                throw new ArgumentNullException(nameof(apiKey));
            }

            using var message = CreateGetUserDictionaryWordsRequest(username, apiKey, offset, limit, dicts);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Paths19M51AqWordsGetResponses200ContentApplicationJsonSchema value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = Paths19M51AqWordsGetResponses200ContentApplicationJsonSchema.DeserializePaths19M51AqWordsGetResponses200ContentApplicationJsonSchema(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> List words in the user&apos;s personal dictionaries. </summary>
        /// <param name="username"> Your username as used to log in at languagetool.org. </param>
        /// <param name="apiKey"> &lt;a target=&apos;_blank&apos; href=&apos;https://languagetool.org/editor/settings/api&apos;&gt;Your API key&lt;/a&gt;. </param>
        /// <param name="offset"> Offset of where to start in the list of words. Defaults to 0. </param>
        /// <param name="limit"> Maximum number of words to return. Defaults to 10. </param>
        /// <param name="dicts"> Comma-separated list of dictionaries to include words from; uses special default dictionary if this is unset. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="username"/> or <paramref name="apiKey"/> is null. </exception>
        public Response<Paths19M51AqWordsGetResponses200ContentApplicationJsonSchema> GetUserDictionaryWords(string username, string apiKey, int? offset = null, int? limit = null, string dicts = null, CancellationToken cancellationToken = default)
        {
            if (username == null)
            {
                throw new ArgumentNullException(nameof(username));
            }
            if (apiKey == null)
            {
                throw new ArgumentNullException(nameof(apiKey));
            }

            using var message = CreateGetUserDictionaryWordsRequest(username, apiKey, offset, limit, dicts);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Paths19M51AqWordsGetResponses200ContentApplicationJsonSchema value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = Paths19M51AqWordsGetResponses200ContentApplicationJsonSchema.DeserializePaths19M51AqWordsGetResponses200ContentApplicationJsonSchema(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateAddUserDictionaryWordRequest(string word, string username, string apiKey, string dict)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/words/add", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/x-www-form-urlencoded");
            var content = new FormUrlEncodedContent();
            content.Add("word", word);
            content.Add("username", username);
            content.Add("apiKey", apiKey);
            if (dict != null)
            {
                content.Add("dict", dict);
            }
            request.Content = content;
            return message;
        }

        /// <summary> Add a word to one of the user&apos;s personal dictionaries. Please note that this feature is considered to be used for personal dictionaries which must not contain more than 500 words. If this is an issue for you, please contact us. </summary>
        /// <param name="word"> The word to be added. Must not be a phrase, i.e. cannot contain white space. The word is added to a global dictionary that applies to all languages. </param>
        /// <param name="username"> Your username as used to log in at languagetool.org. </param>
        /// <param name="apiKey"> &lt;a target=&apos;_blank&apos; href=&apos;https://languagetool.org/editor/settings/api&apos;&gt;Your API key&lt;/a&gt;. </param>
        /// <param name="dict"> Name of the dictionary to add the word to; non-existent dictionaries are created after calling this; if unset, adds to special default dictionary. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="word"/>, <paramref name="username"/> or <paramref name="apiKey"/> is null. </exception>
        public async Task<Response<PathsJ3J268WordsAddPostResponses200ContentApplicationJsonSchema>> AddUserDictionaryWordAsync(string word, string username, string apiKey, string dict = null, CancellationToken cancellationToken = default)
        {
            if (word == null)
            {
                throw new ArgumentNullException(nameof(word));
            }
            if (username == null)
            {
                throw new ArgumentNullException(nameof(username));
            }
            if (apiKey == null)
            {
                throw new ArgumentNullException(nameof(apiKey));
            }

            using var message = CreateAddUserDictionaryWordRequest(word, username, apiKey, dict);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        PathsJ3J268WordsAddPostResponses200ContentApplicationJsonSchema value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = PathsJ3J268WordsAddPostResponses200ContentApplicationJsonSchema.DeserializePathsJ3J268WordsAddPostResponses200ContentApplicationJsonSchema(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Add a word to one of the user&apos;s personal dictionaries. Please note that this feature is considered to be used for personal dictionaries which must not contain more than 500 words. If this is an issue for you, please contact us. </summary>
        /// <param name="word"> The word to be added. Must not be a phrase, i.e. cannot contain white space. The word is added to a global dictionary that applies to all languages. </param>
        /// <param name="username"> Your username as used to log in at languagetool.org. </param>
        /// <param name="apiKey"> &lt;a target=&apos;_blank&apos; href=&apos;https://languagetool.org/editor/settings/api&apos;&gt;Your API key&lt;/a&gt;. </param>
        /// <param name="dict"> Name of the dictionary to add the word to; non-existent dictionaries are created after calling this; if unset, adds to special default dictionary. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="word"/>, <paramref name="username"/> or <paramref name="apiKey"/> is null. </exception>
        public Response<PathsJ3J268WordsAddPostResponses200ContentApplicationJsonSchema> AddUserDictionaryWord(string word, string username, string apiKey, string dict = null, CancellationToken cancellationToken = default)
        {
            if (word == null)
            {
                throw new ArgumentNullException(nameof(word));
            }
            if (username == null)
            {
                throw new ArgumentNullException(nameof(username));
            }
            if (apiKey == null)
            {
                throw new ArgumentNullException(nameof(apiKey));
            }

            using var message = CreateAddUserDictionaryWordRequest(word, username, apiKey, dict);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        PathsJ3J268WordsAddPostResponses200ContentApplicationJsonSchema value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = PathsJ3J268WordsAddPostResponses200ContentApplicationJsonSchema.DeserializePathsJ3J268WordsAddPostResponses200ContentApplicationJsonSchema(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateRemoveUserDictionaryWordRequest(string word, string username, string apiKey, string dict)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/words/delete", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/x-www-form-urlencoded");
            var content = new FormUrlEncodedContent();
            content.Add("word", word);
            content.Add("username", username);
            content.Add("apiKey", apiKey);
            if (dict != null)
            {
                content.Add("dict", dict);
            }
            request.Content = content;
            return message;
        }

        /// <summary> Remove a word from one of the user&apos;s personal dictionaries. </summary>
        /// <param name="word"> The word to be removed. </param>
        /// <param name="username"> Your username as used to log in at languagetool.org. </param>
        /// <param name="apiKey"> &lt;a target=&apos;_blank&apos; href=&apos;https://languagetool.org/editor/settings/api&apos;&gt;Your API key&lt;/a&gt;. </param>
        /// <param name="dict"> Name of the dictionary to remove the word from; if the dictionary is empty upon calling this, it is deleted; if unset, removes from special default dictionary. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="word"/>, <paramref name="username"/> or <paramref name="apiKey"/> is null. </exception>
        public async Task<Response<PathsWjwd9LWordsDeletePostResponses200ContentApplicationJsonSchema>> RemoveUserDictionaryWordAsync(string word, string username, string apiKey, string dict = null, CancellationToken cancellationToken = default)
        {
            if (word == null)
            {
                throw new ArgumentNullException(nameof(word));
            }
            if (username == null)
            {
                throw new ArgumentNullException(nameof(username));
            }
            if (apiKey == null)
            {
                throw new ArgumentNullException(nameof(apiKey));
            }

            using var message = CreateRemoveUserDictionaryWordRequest(word, username, apiKey, dict);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        PathsWjwd9LWordsDeletePostResponses200ContentApplicationJsonSchema value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = PathsWjwd9LWordsDeletePostResponses200ContentApplicationJsonSchema.DeserializePathsWjwd9LWordsDeletePostResponses200ContentApplicationJsonSchema(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Remove a word from one of the user&apos;s personal dictionaries. </summary>
        /// <param name="word"> The word to be removed. </param>
        /// <param name="username"> Your username as used to log in at languagetool.org. </param>
        /// <param name="apiKey"> &lt;a target=&apos;_blank&apos; href=&apos;https://languagetool.org/editor/settings/api&apos;&gt;Your API key&lt;/a&gt;. </param>
        /// <param name="dict"> Name of the dictionary to remove the word from; if the dictionary is empty upon calling this, it is deleted; if unset, removes from special default dictionary. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="word"/>, <paramref name="username"/> or <paramref name="apiKey"/> is null. </exception>
        public Response<PathsWjwd9LWordsDeletePostResponses200ContentApplicationJsonSchema> RemoveUserDictionaryWord(string word, string username, string apiKey, string dict = null, CancellationToken cancellationToken = default)
        {
            if (word == null)
            {
                throw new ArgumentNullException(nameof(word));
            }
            if (username == null)
            {
                throw new ArgumentNullException(nameof(username));
            }
            if (apiKey == null)
            {
                throw new ArgumentNullException(nameof(apiKey));
            }

            using var message = CreateRemoveUserDictionaryWordRequest(word, username, apiKey, dict);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        PathsWjwd9LWordsDeletePostResponses200ContentApplicationJsonSchema value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = PathsWjwd9LWordsDeletePostResponses200ContentApplicationJsonSchema.DeserializePathsWjwd9LWordsDeletePostResponses200ContentApplicationJsonSchema(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }
    }
}
